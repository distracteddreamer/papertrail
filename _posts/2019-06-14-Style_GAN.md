---
layout: post
title:  "Style GAN"
date:   2019-06-14 11:51:32 +0100
categories: jekyll update
---

These are my notes on the paper [A Style-Based Generator Architecture for Generative Adversarial Networks](https://arxiv.org/abs/1812.04948). All mistakes are my own. 

## Architecture
# Progressive GAN
- Used the architecture from PGGAN with a number of changes to the inputs and the processing of intermediate feature maps.

# Input transformation
- Usually a latent code $z$ is sampled from a distribution and transformed a sequence of layers starting from a fully connected layer which increases its dimensionality followed by convolutional layers which transform it into an image. 
- Here the model instead maps $z$ into an intermediate latent space $\mathcal{W}$
- The input to the generator is now in fact a learned $4 \times 4 \times 512$ constant tensor.

# Style transformation
- After $$z$$ is mapped to $w \in \mathcal{W}$, it is transformed to a style $\mathbf{y}$ that consists of a "scale" style $\mathbf{y}_s$ and a "bias" $\mathbf{y}_b$ style.
- These style values are then used as the weights in the adaptive normalisation applied to the feature maps output by each convolutional layer:

    $$\text{AdaIN}(\mathbf{x}_i, \mathbf{y}) = \mathbf{y}_{s, i}\frac{\mathbf{x}_i - \mu(\mathbf{x}_i)}{\sigma(\mathbf{x}_i)} + \mathbf{y}_{b,i}$$
- $\mathcal{W}$ is an intermediate latent space 
- Noise inputs
    - After each convolutional layer noise is inserted into the network in a residual fashion.
    - A single channel image of Gaussian noise (independent for each pixel) is broadcast to same number of channels as the output of each convolutional layer using 1x1 convolutions (I think) and added to the output of the convolutional layer.

# Losses
- WGAN-GP for baseline and non-saturating loss with $R_1$ regularisation for additions. 


##  Significance of styles

# Key properties of model
- Focus is on the generator rather than discriminator
- The layers that transform the input can be thought of as sampling styles from a distrbution conditioned on the input latent code.
- As the outputs of a layer are normalised to have mean of 0, standard deviation of 1, the style applied to the previous stage does not affect the statistics of the next stage

# Style mixing:
- Since the style inputs are fed into the network at various stages, it is possible to input feed the latent space vector for a different styles at different points in the network.
- In order to prevent the model from correlating adjacent styles, a regularisation method was used whereby one style was used upto a randomly selected point after which another style was used.
- When a model is trained with style mixing, if we generate a pair of images A and B using two different styles A and B and a further image which uses style B for a certain set of levels and style A elsewhere, we find that the result is like image A with meaningful attributes from image B depending on the point at which style B is used:
    - For example copying styles input to layers earlier in the network, with coarser resolutions transfers high-level aspects like pose, general hair style, face shape, eyeglasses
    - Middle resolutions transfer smaller scale facial features, hair style, eyes open/closed while keeping fixed the aspects above.
    -  Fine resolutions mainly copy colour scheme and microstructure.
- Style mixing improves Frechet Inception Distance (FID) when using multiple latents during test time (and also when using single latents)

# Stochastic variation
- Faces have stochastic variations such as the positions of hairs but it can be challenging to leverage the randomness from the input latent code to make these aspects of the image vary stochastically.
- Adding random noise to intermediate feature maps means that the latent code is not the only source of randomness
- It turns out that different images generated from the same latent code but with different random inputs added to the intermediate feature maps look very similar but have.
- They suggest that there is pressure on the network to keep adding new content at each stage and the easiest way to introduce stochastic variation is to rely on the added noise.
- The noise is added independently to each pixel its effect is local whereas style is used to scale and bias the whole feature map and affects global attributes.
- The model seems to learn to use these two sources of randomness in this way without explicit guidance. 
- They suggest that if the added noise was used by the model to control global effects such as pose, it would lead to spatially inconsistent results that would be penalised by the discriminator.

## Disentanglement

# Perceptual path length
- A pair either of the latent codes $\mathbf{z}$ or the mappings $\mathbf{w}$ are interpolated at two points spaced apart by $\epsilon = 10^{-4}$. 
- The following is the path length for a given pair of styles $\mathbf{z}_1, \mathbf{z}_2 \in P(\mathbf{z})$ and the fraction of the distance along to part where we should start $t ~ \mathcal{N}(0, 1)$:
- For $\mathcal{Z}$ (where $\text{slerp}$ denotes spherical interpolation):
    
    $$l_\mathcal{Z} = \mathbb{E}\left[\frac{1}{\epsilon^2}d(G(\text{slerp}(\mathbf{z}_1, \mathbf{z}_2; t), G(\text{slerp}(\mathbf{z}_1, \mathbf{z}_2; t)))\right]$$

- For $\mathcal{W}$ (where $\text{lerp}$ denotes linear interpolation):
    
    $$l_\mathcal{W} = \mathbb{E}\left[\frac{1}{\epsilon^2}d(G(\text{lerp}(f(\mathbf{z}_1), f(\mathbf{z}_2); t), G(\text{lerp}(f(\mathbf{z}_1), f(\mathbf{z}_2); t)))\right]$$

- The expected values of this over all possible styles and starting points is estimated by obtaining this value for 100k samples.
- If the latent space is entangled then there might dependencies between different factors of variation that lead to surprising features in the images that are not present in the images generated using the endpoint styles. 
- The style generator with noise inputs does indeed have a lower perceptual path length for interpolation in $\mathcal{W}$ compared to the outputs for interpolations in $\mathcal{Z}$ for a non-style generator with the same architecture in other respects. 
- If $\mathcal{W}$ is actually a disentangled mapping of $\mathcal{Z}$ it might have regions not found on the input manifold (not 100% sure what they mean by this) which the generator does not reconstruct properly.
- Evidence that this is the case is provided by the fact that the average path length for just the end points i.e. $$t \in \{ 0, 1 \}$$ (so that we move away just a little from each style) is smaller than across the whole path.

# Linear separability
- They train a classifier on 40 attributes of CelebA-HQ - it seems that it is a binary classifier predicting one of a pair of attributes e.g. male or female.
- The classifier shares the same architecture as the discriminator.
- They then classify a set of generated images using this classifier, selecting 100k of those with the highest confidence - these predictions are denoted $Y$
- The latent vector for each of these - either $\mathbf{z}$ or $\mathbf{w}$ depending on whether we are using traditional or style-based - is then classified by a linear SVM and the predictions are denoted $X$
- Then the conditional entropy $H(Y\vert X)$ is estimated (presumably $p(x, y)$, $p(x)$ are the frequencies of the predicted classifier labels and of the pairs of predicted classifier labels and predicted SVM labels).
- Separability score is $\exp\left(\sum_i H(Y_i\vert X_i)\right)$ i.e. the exponential of the sum of entropies for each attribute.
- Note that the classifier predicts a label for the generated image whilst the input to the SVM are the latent vectors.
- The score measures how separability of the images relative to the latent vectors - A high conditional entropy means that more information needs to be added by the generator to the latent vectors in order to be able to separate the images.
- Turns out that $\mathcal{W}$ is more separable than $\mathcal{Z}$ and the deeper the mapping network the better separable in general. 
- An interesting finding was that simply mapping $Z$ to a latent space before feeding it directly to a traditional generator (rather than transforming to styles before) made the latents more separable as well as lowering the FID. 

## Topics
# ML
GAN, style transfer, latent space interpolation



     




  