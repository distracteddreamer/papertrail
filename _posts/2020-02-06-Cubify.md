---
layout: post
title:  Cubify Algorithm
date:   2020-02-06 21:10:54
categories: jekyll update
---
Cubify is an algorithm introduced in the paper [Mesh R-CNN](https://arxiv.org/pdf/1906.02739) (my notes [here]({{ site.baseurl }}/jekyll/update/2019/06/13/Mesh_RCNN.html)) for converting a volume where each voxel's value is its probability of occupancy into a triangle-based mesh. The paper provides a naive implementation in pseudo-code. 

![cubify pseudo-code figure from Mesh_RCNN paper]({{ site.baseurl }}/assets/Cubify/pseudo-code.png)

In simple terms if a given voxel has a probability above the threshold $$\tau$$ then for each of its face, the face is discared if the neighbour with whom the face is shared also has a probability greater than the threshold. Equivalently (the approach we follow code below) for each face of a given voxel, the face is kept if the neighbour with whom it is shared has a probability less or equal to the threshold. Note that each face is then split into two triangles to produce a triangular mesh. 

They indicate that the above algorithm can be implemented efficiently using 3D convolutions in place of the nested for-loops. Below I have implemented a version in PyTorch. All mistakes are my own.

```python
class Cubify(torch.nn.Module):
    def __init__(self, tau):
        super(Cubify, self).__init__()
        self.tau = tau
        self.copy_probs = torch.nn.Conv3d(in_channels=1, out_channels=6, kernel_size=3, padding=1,
                                         bias=False)
        self.faces = self._make_faces()
        self.copy_probs.weight.data = (self._make_kernel())
        self.copy_probs.weight.requires_grad = False
        
    def _make_kernel(self):
        # Each of the 6 filters has a 1 at just one position
        # corresponding to each of the relative locations 
        # handled by the conditions in the algorithm above.
        # When applied it results in copying the value 
        # from the voxel at that location.
        
        kernel = torch.zeros((6, 3, 3, 3))
        copy_inds = [[0, 0, 1, 1], # x1 
                     [1, 2, 1, 1], # x2
                     [2, 1, 0, 1], # y1
                     [3, 1, 2, 1], # y2
                     [4, 1, 1, 0], # z1
                     [5, 1, 1, 2]] # z2
        
        copy_inds = torch.tensor(copy_inds)
        
        kernel[tuple(copy_inds[:, i] for i in range(4))] = 1
        return kernel[:, None]
        
        
    def _make_verts(self, inputs):
        # Make a grid of the size of points 
        grid = torch.meshgrid(*[torch.arange(0, inputs.size(i + 1)) for i in range(3)])
        grid = torch.stack(grid, dim=-1).long()  # (L, H, W, 3)
        
        # Regarding each point as the centre of a cube, these are the offsets 
        # for each of the corners of the cube
        offsets = torch.tensor([[0,0,0], 
                               [0,0,1], 
                               [0,1,0], 
                               [0,1,1],
                               [1,0,0], 
                               [1,0,1], 
                               [1,1,0], 
                               [1,1,1]])
        
        # Add the offsets to get the corner coordinates for each point
        verts = grid[..., None, :] + offsets[None, None, None] # (L, H, W, 8, 3)
        
        return verts
        
    def _make_faces(self):
        # Define the pair of triangular faces corresponding to each face
        # of a cube
        
        # 000 - 0
        # 001 - 1
        # 010 - 2
        # 011 - 3
        # 100 - 4
        # 101 - 5
        # 110 - 6
        # 111 - 7
        
        # These are the indices for the vertices for the faces for first cube
        x1 = [[0, 1, 2], [1, 2, 3]]
        x2 = [[4, 5, 6], [5, 6, 7]]
        y1 = [[0, 1, 4], [1, 4, 5]]
        y2 = [[2, 3, 6], [3, 6, 7]]
        z1 = [[0, 2, 4], [2, 4, 6]]
        z2 = [[1, 3, 5], [3, 5, 7]]
        
        faces = torch.tensor([x1, x2, y1, y2, z1, z2]) # (6, 2, 3)
        return faces
        
    def forward(self, inputs):
        batch_size = inputs.size(0)
        
        # Apply the first condition
        include = (inputs.view(batch_size, -1, 1) > self.tau) # (N, L*H*W, 1)
        
        # Copy the probabilities at the 6 surrounding voxels
        _probs = self.copy_probs(inputs) # (N, 6, L, H, W)
        # Reshape to make these the last channel
        probs = _probs.permute(0, 2, 3, 4, 1) # (N, L, H, W, 6)
        # Generate corner coordinates for each voxel 
        _verts = self._make_verts(inputs[:, 0])  # (L, H, W, 8, 3)
        verts = _verts.view(-1, 8, 3) # (L*H*W, 8, 3)
        
        # Apply the conditions for surrounding voxels
        exclude_surround = (probs <= self.tau).view(batch_size, -1, 6) # (N, L*H*W, 6)
        
        # Keep a face if voxel has sufficient probability
        # and neighbouring voxel has probability below tau
        faces_mask = exclude_surround & include # (N, L*H*W, 6)
        
        #masks = (probs < self.tau).view(-1, 6) # (L*H*W, 6)
        #masks = masks & (inputs.view(-1, 1) >= self.tau)
        
        # As each voxel has its own copy of all its 8 vertices 
        # e.g. for the i-th voxel it is verts[i] and since there
        # are 8 vertices per voxel, for every subsequent voxel increase 
        # the voxel indices by 1 so the we index into the right faces 
        _offset = 8 * torch.arange(0, torch.prod(torch.tensor(inputs.size()[2:]))).long() #(L*H*W)
        offset = _offset[None].repeat(batch_size, 1) #(N, L*H*W)
        faces = self.faces + offset[:, :, None, None, None] # (N, L*H*W, 6, 2, 3)
        
        # So that the vertices corresponding to the faces may be selected 
        batch_inds = torch.arange(inputs.size(0))[:, None, None, None] \
                        .repeat(1, faces.size(1), 6, 2) # (N, L*H*W, 6, 2)
        
        batch_inds = batch_inds[faces_mask].view(-1) #(M * 2)
        faces_keep = faces[faces_mask].view(-1, 3) #(M * 2, 3)
        return verts.view(-1, 3), faces_keep, batch_inds
```
Here we run it on a small dataset to demonstrate that it works on a batch of volumes that result in variable-sized meshes. All the vertices are generated for the grid size and the tensor `batch_inds` is used to index into `faces` as needed. 
```python
cubify = Cubify(0.5)
inputs = torch.zeros((3, 1, 5, 5, 5))

vals = torch.from_numpy((((np.indices((5, 5)) - 2)**2).sum(0) <= (2**2)).astype('float32'))
inputs[0, 0, :, :, 1:3] = vals[..., None].repeat(1, 1, 2)
inputs[1, 0, 2, 2, 2] = 1.
inputs[2, 0, 1:-1, 1:-1, 1:-1] = 1.

v, f, b = cubify(inputs)

points = v.numpy()
faces = f.numpy()
binds = b.numpy()

import sys
from matplotlib.animation import FuncAnimation

def update(i, f):
    
    p = points[f[i]]
    p = np.concatenate([p, p[:1]])
    ax.scatter(p[:,0], p[:,1], p[:,2], color='k')
    ax.plot(p[:,0], p[:,1], p[:,2], color='k')
        
    plt.axis('off')
        
    return ax

for b in range(len(inputs)):
    fig = plt.figure()
    ax =fig.add_subplot(111, projection='3d')
    faces_b = faces[binds==b]
    anim = FuncAnimation(fig, lambda i: update(i, faces_b), frames=np.arange(len(faces_b)), interval=200);
    a = anim.save('mesh{}.gif'.format(b), dpi=40, writer='imagemagick');
```

**Approximate cylinder with height 2, diameter 5**
<br>
![gif showing construction of mesh for an approximate cylinder with height 2, diameter 5]({{ site.baseurl }}/assets/Cubify/mesh0.gif)
<br>
**Unit cube**
<br>
![gif showing construction of mesh for a unit cube]({{ site.baseurl }}/assets/Cubify/mesh1.gif)
<br>
**3 x 3 cube**
<br>
![gif showing construction of mesh for a 3 x 3 x 3 cube]({{ site.baseurl }}/assets/Cubify/mesh2.gif)
