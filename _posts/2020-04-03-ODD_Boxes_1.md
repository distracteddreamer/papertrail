---
layout: post
title:  Object Detection Deconstructed â€” Boxes 1
date:   2020-04-03 01:06:52
categories: jekyll update
---

```python
import matplotlib.pyplot as plt
import numpy as np
from skimage.transform import resize
%matplotlib inline
```

## Bounding boxes 

In the simplest form you locate an object within an image (or a volume) by drawing a box around it. Bounding boxes can be represented in a number ways. We will focus on the $xyxy$ format where the box is represented by its top-left and bottom-right corner co-ordinates $[x_1, y_1, x_2, y_2]$ but will also sometimes use the $whxy$ format where we specify the width, height, and $x$ and $y$ coordinates of the centre, $[w, h, x_\text{centre}, y_\text{centre}]$. 

Note that in our definition $x_2$ and $y_2$ will be *inside* the box. But these can vary in elsewhere. Usually it won't make a huge difference but will cause problems with boxes at the edge of an image. 

From the start we will work with arbitrary sized tensors of boxes. These can have any number of dimensions and the only rule is that the size of the last dimension is 4. 


```python
def to_whxy(box):
    """Return width, height, x center, and y center for an
    array of boxes.
    
    box: An arbitray dimensional tensor with a final dimension of size 4
    
    """
    
    # Add 1 to get dims since x2,y2 inside 
    w = box[..., 2] - box[..., 0] + 1
    h = box[..., 3] - box[..., 1] + 1
    x_ctr = box[..., 0] + 0.5 * (w - 1)
    y_ctr = box[..., 1] + 0.5 * (h - 1)
    return w, h, x_ctr, y_ctr 
```


```python
def plot_rectangle(box, ax=None, clr='b', linewidth=1):
    x1, y1, x2, y2 = box
    w, h, xc, yc = to_whxy(box)
    # -1 because box is plotted between x1 to x1 + w when we want x1 to x1 + w - 1
    ax.add_artist(plt.Rectangle(xy=(x1, y1), height=h-1, width=w-1, fill=False, color=clr,
                               linewidth=linewidth))
    
```


```python
img = plt.imread('hibiscus-3601937_1920.jpg')
img = resize(img, (600, 1000))
fig, ax = plt.subplots(1, figsize=(12, 8))
ax.imshow(img)
ax.axis('off');
bbox1 = [85,   0, 315, 220]
bbox2 = [330,   140, 650, 480]
plot_rectangle(np.stack(bbox1), ax=ax, clr='w', linewidth=3);
plot_rectangle(np.stack(bbox2), ax=ax, clr='w', linewidth=3);

img2 = plt.imread('flowers-4365828_1920.jpg')
img2 = resize(img2, (600, 1000))
bbox3 = [130,   150, 505, 440]
fig, ax = plt.subplots(1, figsize=(12, 8))
ax.imshow(img2)
ax.axis('off');
plot_rectangle(np.stack(bbox3), ax=ax, clr='w', linewidth=3);
```


![png]({{ site.baseurl }}/assets/ODD_Boxes_1/output_5_0.png)



![png]({{ site.baseurl }}/assets/ODD_Boxes_1/output_5_1.png)


## Anchor boxes

How do you predict bounding boxes for an image? One approach is to take lots of boxes of different sizes and aspect ratios evenly spaced apart on a grid across the image. If you define these boxes appropriately then there is a good chance that one or more of them bound the objects in the image fairly well. We call these "anchor boxes". This turns the problem into something of a classification task whereby you try to predict what is inside each region. For example, does it have an object or not and if so what is the class label of that object? 

We can keep all those boxes which confidently predict an object and discard the rest. However the initial boxes are not good enough by themselves so we also want the model to predict a 
linear transformation of the boxes consisting of stretching and translation that till turn them into boxes that better fit the objects. 

In the next post we will cover anchor boxes in depth: how to generate them and how to use them in practice. 
